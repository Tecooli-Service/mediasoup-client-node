"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Werift = void 0;
const werift_1 = require("werift");
const sdpTransform = __importStar(require("sdp-transform"));
const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
const ortc = __importStar(require("../ortc"));
const RemoteSdp_1 = require("./sdp/RemoteSdp");
const Logger_1 = require("../Logger");
const HandlerInterface_1 = require("./HandlerInterface");
const logger = new Logger_1.Logger('werift');
const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
class Werift extends HandlerInterface_1.HandlerInterface {
    constructor() {
        super();
        // Map of RTCTransceivers indexed by MID.
        this._mapMidTransceiver = new Map();
        this._transportReady = false;
    }
    static createFactory() {
        return () => new Werift();
    }
    get name() {
        return 'werift';
    }
    close() {
        logger.debug('close()');
        // Close RTCPeerConnection.
        if (this._pc) {
            try {
                this._pc.close();
            }
            catch (error) { }
        }
    }
    async getNativeRtpCapabilities() {
        const caps = {
            codecs: [
                {
                    kind: 'audio',
                    mimeType: 'audio/opus',
                    clockRate: 48000,
                    channels: 2
                },
                {
                    kind: 'video',
                    mimeType: 'video/VP8',
                    clockRate: 90000,
                    rtcpFeedback: [
                        { type: 'ccm', parameter: 'fir' },
                        { type: 'nack' },
                        { type: 'nack', parameter: 'pli' },
                        { type: 'goog-remb' }
                    ]
                }
            ]
        };
        return caps;
    }
    async getNativeSctpCapabilities() {
        logger.debug('getNativeSctpCapabilities()');
        return {
            numStreams: SCTP_NUM_STREAMS
        };
    }
    run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
        logger.debug('run()');
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
        });
        this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
        };
        this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
        };
        this._pc = new werift_1.RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'unified-plan' }, additionalSettings), proprietaryConstraints);
        // Handle RTCPeerConnection connection status.
        this._pc.connectionStateChange.subscribe((state) => {
            switch (state) {
                case 'connecting':
                    this.emit('@connectionstatechange', 'connecting');
                    break;
                case 'connected':
                    this.emit('@connectionstatechange', 'connected');
                    break;
            }
        });
    }
    // todo impl
    async updateIceServers(iceServers) { }
    // todo impl
    async restartIce(iceParameters) { }
    // todo impl
    // @ts-expect-error
    async getTransportStats() { }
    // todo impl
    async send({ track, encodings, codecOptions, codec }) { }
    // todo impl
    async stopSending(localId) { }
    // todo impl
    async replaceTrack(localId, track) { }
    // todo impl
    async setMaxSpatialLayer(localId, spatialLayer) { }
    // todo impl
    async setRtpEncodingParameters(localId, params) { }
    // todo impl
    // @ts-expect-error
    async getSenderStats(localId) { }
    // todo impl
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol, priority }) { }
    async receive({ trackId, kind, rtpParameters }) {
        this._assertRecvDirection();
        logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
        const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
        this._remoteSdp.receive({
            mid: localId,
            kind,
            offerRtpParameters: rtpParameters,
            streamId: rtpParameters.rtcp.cname,
            trackId
        });
        const offer = new werift_1.RTCSessionDescription(this._remoteSdp.getSdp(), 'offer');
        logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
        // May need to modify codec parameters in the answer based on codec
        // parameters in the offer.
        sdpCommonUtils.applyCodecParameters({
            offerRtpParameters: rtpParameters,
            answerMediaObject
        });
        answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
        if (!this._transportReady)
            await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
        logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
        const transceiver = this._pc
            .getTransceivers()
            .find((t) => t.mid === localId);
        if (!transceiver)
            throw new Error('new RTCRtpTransceiver not found');
        // Store in the map.
        this._mapMidTransceiver.set(localId, transceiver);
        return {
            localId,
            // todo fix
            track: transceiver.receiver.tracks[0],
            // todo fix
            rtpReceiver: transceiver.receiver
        };
    }
    async stopReceiving(localId) {
        this._assertRecvDirection();
        logger.debug('stopReceiving() [localId:%s]', localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver)
            throw new Error('associated RTCRtpTransceiver not found');
        this._remoteSdp.closeMediaSection(transceiver.mid);
        const offer = new werift_1.RTCSessionDescription(this._remoteSdp.getSdp(), 'offer');
        logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
        await this._pc.setLocalDescription(answer);
    }
    // todo impl
    // @ts-expect-error
    async getReceiverStats(localId) { }
    // todo impl
    async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
        this._assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
        };
    }
    async _setupTransport({ localDtlsRole, localSdpObject }) {
        if (!localSdpObject)
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        // Get our local DTLS parameters.
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
        });
        // Set our DTLS role.
        dtlsParameters.role = localDtlsRole;
        // Update the remote DTLS role in the SDP.
        this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
        // Need to tell the remote transport about our parameters.
        await this.safeEmitAsPromise('@connect', { dtlsParameters });
        this._transportReady = true;
    }
    _assertSendDirection() {
        if (this._direction !== 'send') {
            throw new Error('method can just be called for handlers with "send" direction');
        }
    }
    _assertRecvDirection() {
        if (this._direction !== 'recv') {
            throw new Error('method can just be called for handlers with "recv" direction');
        }
    }
}
exports.Werift = Werift;
