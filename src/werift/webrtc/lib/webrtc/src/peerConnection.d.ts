import Event from "rx.mini";
import { EventTarget } from "./helper";
import { ConnectionState, Kind, SignalingState } from "./types/domain";
import { RTCDataChannel } from "./dataChannel";
import { RTCRtpCodecParameters, RTCRtpHeaderExtensionParameters } from "./media/parameters";
import { RTCRtpReceiver } from "./media/rtpReceiver";
import { RTCRtpSender } from "./media/rtpSender";
import { Direction, RTCRtpTransceiver, TransceiverOptions } from "./media/rtpTransceiver";
import { MediaDescription, RTCSessionDescription } from "./sdp";
import { RTCDtlsTransport } from "./transport/dtls";
import { IceGathererState, IceTransportState, RTCIceCandidate, RTCIceCandidateJSON, RTCIceTransport } from "./transport/ice";
import { RTCSctpTransport } from "./transport/sctp";
import { MediaStreamTrack } from "./media/track";
export declare class RTCPeerConnection extends EventTarget {
    readonly cname: string;
    iceTransport: RTCIceTransport;
    dtlsTransport: RTCDtlsTransport;
    sctpTransport?: RTCSctpTransport;
    masterTransportEstablished: boolean;
    configuration: Required<PeerConfig>;
    connectionState: ConnectionState;
    iceConnectionState: IceTransportState;
    iceGatheringState: IceGathererState;
    signalingState: SignalingState;
    negotiationneeded: boolean;
    readonly transceivers: RTCRtpTransceiver[];
    readonly iceGatheringStateChange: Event<["new" | "gathering" | "complete"]>;
    readonly iceConnectionStateChange: Event<["disconnected" | "closed" | "completed" | "failed" | "new" | "connected" | "checking"]>;
    readonly signalingStateChange: Event<["closed" | "stable" | "have-local-offer" | "have-remote-offer" | "have-local-pranswer" | "have-remote-pranswer"]>;
    readonly connectionStateChange: Event<["disconnected" | "closed" | "failed" | "new" | "connecting" | "connected"]>;
    readonly onDataChannel: Event<[RTCDataChannel]>;
    readonly onTransceiver: Event<[RTCRtpTransceiver]>;
    readonly onIceCandidate: Event<[RTCIceCandidate]>;
    readonly onnegotiationneeded: Event<[]>;
    ondatachannel?: ((event: {
        channel: RTCDataChannel;
    }) => void) | null;
    private readonly router;
    private readonly certificates;
    private sctpRemotePort?;
    private remoteDtls?;
    private remoteIce?;
    private seenMid;
    private currentLocalDescription?;
    private currentRemoteDescription?;
    private pendingLocalDescription?;
    private pendingRemoteDescription?;
    private isClosed;
    constructor({ codecs, headerExtensions, iceServers, iceTransportPolicy, }?: Partial<PeerConfig>);
    get localDescription(): RTCSessionDescription | undefined;
    get remoteDescription(): RTCSessionDescription | undefined;
    private get _localDescription();
    private get _remoteDescription();
    private getTransceiverByMid;
    private getTransceiverByMLineIndex;
    createOffer(): Promise<RTCSessionDescription>;
    createDataChannel(label: string, options?: Partial<{
        maxPacketLifeTime?: number;
        protocol: string;
        maxRetransmits?: number;
        ordered: boolean;
        negotiated: boolean;
        id?: number;
    }>): RTCDataChannel;
    removeTrack(sender: RTCRtpSender): void;
    private needNegotiation;
    private createTransport;
    private createSctpTransport;
    setLocalDescription(sessionDescription: RTCSessionDescription): Promise<RTCSessionDescription | undefined>;
    private setLocal;
    addIceCandidate(candidateMessage: RTCIceCandidateJSON): Promise<void>;
    private connect;
    private localRtp;
    private remoteRtp;
    private validateDescription;
    setRemoteDescription(sessionDescription: {
        type: "offer" | "answer";
        sdp: string;
    }): Promise<void>;
    addTransceiver(trackOrKind: Kind | MediaStreamTrack, options?: Partial<TransceiverOptions>): RTCRtpTransceiver;
    getTransceivers(): RTCRtpTransceiver[];
    getSenders(): RTCRtpSender[];
    getReceivers(): RTCRtpReceiver[];
    addTrack(track: MediaStreamTrack): RTCRtpSender;
    createAnswer(): Promise<RTCSessionDescription>;
    close(): Promise<void>;
    private assertNotClosed;
    private updateIceGatheringState;
    private updateIceConnectionState;
    private setSignalingState;
    private setConnectionState;
    private dispose;
}
export declare function createMediaDescriptionForTransceiver(transceiver: RTCRtpTransceiver, cname: string, direction: Direction, mid: string): MediaDescription;
export declare function createMediaDescriptionForSctp(sctp: RTCSctpTransport, mid: string): MediaDescription;
export declare function addTransportDescription(media: MediaDescription, dtlsTransport: RTCDtlsTransport): void;
export declare function allocateMid(mids: Set<string>): string;
export declare type PeerConfig = {
    codecs: Partial<{
        audio: RTCRtpCodecParameters[];
        video: RTCRtpCodecParameters[];
    }>;
    headerExtensions: Partial<{
        audio: RTCRtpHeaderExtensionParameters[];
        video: RTCRtpHeaderExtensionParameters[];
    }>;
    iceTransportPolicy: "all" | "relay";
    iceServers: IceServer[];
};
export declare type IceServer = {
    urls: string;
    username?: string;
    credential?: string;
};
export declare const defaultPeerConfig: PeerConfig;
