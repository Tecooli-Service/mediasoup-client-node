{"version":3,"file":"vp8.js","sourceRoot":"","sources":["../../../src/rtp/codecs/vp8.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * https://tools.ietf.org/html/rfc7741#section-4.2\n *\n *       0 1 2 3 4 5 6 7\n *      +-+-+-+-+-+-+-+-+\n *      |X|R|N|S|R| PID | (REQUIRED)\n *      +-+-+-+-+-+-+-+-+\n * X:   |I|L|T|K| RSV   | (OPTIONAL)\n *      +-+-+-+-+-+-+-+-+\n * I:   |M| PictureID   | (OPTIONAL)\n *      +-+-+-+-+-+-+-+-+\n * L:   |   TL0PICIDX   | (OPTIONAL)\n *      +-+-+-+-+-+-+-+-+\n * T/K: |TID|Y| KEYIDX  | (OPTIONAL)\n *      +-+-+-+-+-+-+-+-+\n *  S: Start of VP8 partition.  SHOULD be set to 1 when the first payload\n *     octet of the RTP packet is the beginning of a new VP8 partition,\n *     and MUST NOT be 1 otherwise.  The S bit MUST be set to 1 for the\n *     first packet of each encoded frame.\n */\n\nconst vp8HeaderSize = 1;\n\nexport class VP8 {\n  x: number;\n  n: number;\n  s: number;\n  pid: number;\n  i: number;\n  l: number;\n  t: number;\n  k: number;\n  pictureId: number;\n  tloPicIdx: number;\n  payload: Buffer;\n\n  static payLoader(mtu: number, payload: Buffer) {\n    const maxFragmentSize = mtu - vp8HeaderSize;\n\n    let payloadDataRemaining = payload.length;\n    let payloadDataIndex = 0;\n\n    if (Math.min(maxFragmentSize, payloadDataRemaining) <= 0) return [];\n\n    const payloads: Buffer[] = [];\n    while (payloadDataRemaining > 0) {\n      const currentFragmentSize = Math.min(\n        maxFragmentSize,\n        payloadDataRemaining\n      );\n      const out: { [key: number]: number } = {};\n      if (payloadDataRemaining === payload.length) {\n        out[0] = 0x00;\n      }\n      payload\n        .slice(payloadDataIndex, payloadDataIndex + currentFragmentSize)\n        .forEach((v, i) => {\n          out[vp8HeaderSize + i] = v;\n        });\n      payloads.push(\n        Buffer.from(\n          Object.keys(out)\n            .sort()\n            .map((i) => out[Number(i)])\n        )\n      );\n\n      payloadDataRemaining -= currentFragmentSize;\n      payloadDataIndex += currentFragmentSize;\n    }\n\n    return payloads;\n  }\n\n  static deSerialize(payload: Buffer) {\n    const p = new VP8();\n    let payloadIndex = 0;\n    p.x = (payload[payloadIndex] & 0x80) >> 7;\n    p.n = (payload[payloadIndex] & 0x20) >> 5;\n    p.s = (payload[payloadIndex] & 0x10) >> 4;\n    p.pid = payload[payloadIndex] & 0x07;\n\n    payloadIndex++;\n\n    if (p.x === 1) {\n      p.i = (payload[payloadIndex] & 0x80) >> 7;\n      p.l = (payload[payloadIndex] & 0x40) >> 6;\n      p.t = (payload[payloadIndex] & 0x20) >> 5;\n      p.k = (payload[payloadIndex] & 0x10) >> 4;\n      payloadIndex++;\n    }\n\n    if (p.i == 1) {\n      // PID present?\n      if ((payload[payloadIndex] & 0x80) > 0) {\n        // M == 1, PID is 16bit\n        payloadIndex += 2;\n      } else {\n        payloadIndex++;\n      }\n    }\n\n    if (p.l == 1) {\n      payloadIndex++;\n    }\n\n    if (p.t == 1 || p.k == 1) {\n      payloadIndex++;\n    }\n\n    if (payloadIndex >= payload.length) {\n      throw new Error(\"Payload is not large enough\");\n    }\n\n    p.payload = payload.slice(payloadIndex);\n    return p;\n  }\n\n  static isPartitionHead(packet: Buffer) {\n    const p = VP8.deSerialize(packet);\n    return p.s === 1;\n  }\n}\n"]}